## 装饰（Decorator）模式 ##

装饰模式又名包装（Wrapper）模式。装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

装饰模式中的角色有：

抽象构件（Component）角色、具体构件（ConcreteComponent）角色、装饰（Decorator）角色、具体装饰（ConcreteDecorator）角色。

在以下情况下应当使用装饰模式：

* 需要扩展一个类的功能，或给一个类增加附加责任。
* 需要动态的给一个对象增加功能，这些功能可以再动态地撤销。
* 需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。


装饰模式的优缺点：

* 装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。

	装饰模式允许系统动态的决定贴上一个需要的“装饰”，或者除掉一个不需要的“装饰”。继承关系则不同，继承关系是静态的，它在系统运行前就决定了。

* 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。

* 这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错。

	不同的装饰类在排列组合时会产生不合理的或荒谬的组合，或是制造出循环引用的错误来。

* 由于使用装饰模式可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得差错变得困难，特别是这些对象看上去都很相像。


装饰者模式动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

* 装饰者和被装饰对象有相同的超类型。这是为了利用继承达到类型匹配，而不是为了获得行为。
* 可以用一个或多个装饰者包装一个对象。
* 在任何需要原始对象的场合，都可以用装饰过的对象代替它。
* 装饰者可以在所委托被装饰者的行为之前或者之后，加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
* 对象可以在任何时候被装饰，所以可以在运行时动态的、不限量的用你喜欢的装饰者来装饰对象。
* 装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。
* 装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变得更复杂。


JDK 里的应用：

	java.io.BufferedInputStream(InputStream)
	java.io.DataInputStream(InputStream)
	java.io.BufferedOutputStream(OutputStream)
	java.util.zip.ZipOutputStream(OutputStream)
	java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()

