                                                                        观察者(Observer)模式

观察者模式属于对象的行为模式，又叫做发布-订阅(Publish/Subscribe)模式、模型-视图(Model/View)模式、源-监听器模式(Source/Listener)等。

观察者模式定义了一种一对多的依赖关系，让多个观察着对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

观察者模式涉及到的角色有：
抽象主题(Subject)角色、抽象观察者(Observer)角色、具体主题(Concrete Subject)角色、具体观察者(Concrete Observer)角色。

观察者模式的优点：
1，观察者模式在被观察者和观察者之间建立一个抽象的耦合。
被观察者角色所知道的只是一个具体观察者聚集，每一个具体观察者都符合一个抽象观察者的接口。
被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。
由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。
如果被观察者和观察者都被扔到一起，那么这个对象必然跨越抽象化和具体化层次。
2，观察者模式支持广播通信，被观察者会向所有的登记过的观察者发出通知。

观察者模式的缺点：
1，如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
2，如果在被观察者和观察者之间有循环依赖的话，观察者可能会触发它们之间进行循环调用，导致系统崩溃。
比如被观察者发生变化通知观察者更新自己，而观察者持有一个被观察者对象，
又改变了被观察者的状态，这样就造成了递归调用。要特别注意这一点。
3，如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的。
4，虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，
但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的。


JDK内置的对观察者模式的支持是java.util.Observable(主题)和Observer(观察者)。但是需要注意：
1，不要依赖于观察者被通知的次序。
不论何种观察者模式的实现，这一点都不能违背，否则就不是所认为的松耦合。
2，Observable是个抽象类而不是接口，如果它不能满足需要，可以自己实现观察者模式。
3，使用观察者模式时，可以从被观察者处推(push)或拉(pull)数据。


JDK里的应用：

java.util.EventListener
javax.servlet.http.HttpSessionBindingListener
javax.servlet.http.HttpSessionAttributeListener
javax.faces.event.PhaseListener