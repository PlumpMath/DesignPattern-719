                                                                           命令(Command)模式

命令模式属于对象的行为模式。
命令模式把一个请求或者操作封装到一个对象中。
它允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。
命令模式是对命令的封装。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。
每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行操作。
命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，
更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。

命令允许请求的一方和接收请求的一方能够独立演化，从而具有以下的优点：
1，命令模式使得新的命令很容易地被加入到系统里。
2，允许接收请求的一方决定是否要否决请求。
3，能较容易的设计一个命令队列。
4，可以容易的实现对请求的Undo和Redo。
5，在需要的情况下，可以较容易的将命令记入日志。

命令模式涉及到的角色有：
客户(Client)角色、命令(Command)角色、具体命令(ConcreteCommand)角色、请求者(Invoker)角色、接收者(Receiver)角色。


命令模式的实现

首先命令应当"重"一些还是"轻"一些（轻重都是对于承担的责任而言）。
在不同的情况下，可以做不同的选择。如果把命令设计的轻，那么它只是提供了一个请求者和接收者之间的耦合而已，命令代表请求者实现请求。
相反，如果把命令设计的重，那么它就应当实现所有的细节，包括请求所代表的操作，而不再需要接收者了。
当一个系统没有接收者时，就可以采用这种做法。
更常见是处于最轻和最重的两个极端之间的情况。命令类动态的决定调用哪一个接收者类。
其次是是否支持undo和redo。如果一个命令类提供一个方法撤销以或恢复其操作的效果，那它就是支持undo和redo。
具体命令类需要存储状态信息，包括：
1，接收者对象实际上实施请求所代表的操作。
2，对接收者对象所作的操作所需要的参数。
3，接收者对象的最初的状态。
接收者必须提供适当的方法，使命令类可以通过调用这个方法，以便接收者类恢复原有状态。
如果只需要提供一层的undo和redo，那么系统只需要存储最后被执行的那个命令对象。
如果需要支持多层的undo和redo，那么系统就需要存储曾经被执行过的命令的清单，清单能允许的最大的长度便是系统所支持的undo和redo的层数。
沿着清单逆着执行清单上的命令的反命令便是undo，沿着清单顺着执行清单上的命令便是redo。


命令模式的适用情况
1，使用命令模式作为callback在面向对象系统中的替代。
callback讲的便是先讲一个函数登记上，然后在以后调用此函数。
2，需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命期。
换言之，原先的请求发出者可能已经不在了，而命令对象本身仍然是活动的。
这时命令的接收者可以是在本地，也可以在网络的另外一个地址。命令对象可以在串行化之后传送到另外一台机器上去。
3，系统需要支持命令的撤销(undo)。
命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo方法，把命令所产生的效果撤销掉。
命令对象还可以提供redo方法，以供客户端在需要时，再重新实施命令的效果。
4，如果一个系统要将系统中所有的数据更新到日志里，以便在系统崩溃时，可以根据日志里读回所有的数据更新命令，
重新调用execute()方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。
5，一个系统需要支持交易(transaction)，一个交易结构封装了一组数据更新命令。
使用命令模式来实现交易结构可以使系统增加新的交易类型。

命令模式的优点
1，命令模式把请求一个操作的对象和知道怎么执行一个操作的对象分割开。
2，命令类与其他任何别的类一样，可以修改和推广。
3，可以把命令对象聚合在一起，合成为合成命令，比如demo3中的宏命令。
4，由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。

命令模式的缺点
1，使用命令模式会导致某些系统有过多的具体命令类。
某些系统可能需要几十个甚至上百个具体命令类，这使得命令模式在这样的系统中变得不实际。