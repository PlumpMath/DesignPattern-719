                                                                               调停者(Mediator)模式

调停者模式是对象的行为模式。调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用，从而使它们可以较松散的耦合。
当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用，从而保证这些相互作用可以彼此独立的变化。


为什么需要调停者模式？

如图 对象关系图1.PNG 所示，这个系统里面有大量的对象，这些对象既会影响别的对象，又会被别的对象影响，因此常常叫做同事(Colleague)对象。
这些同事对象通过彼此的相互作用形成系统的行为。从图中可以看出，几乎每一个对象都需要与其他的对象发生相互作用，
而这种相互作用表现为一个对象与另一个对象的直接耦合。这是一个过度耦合的系统。

通过引入调停者对象(Mediator)，可以将系统的网状结构变成以调停者为中心的形状结构，如图 对象关系图2.PNG 所示。
在这个系统中，同事对象不再通过直接的联系与另一个对象发生相互作用；相反地，它通过调停者对象与另一个对象发生相互作用。
调停者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入造成大量的修改工作。


什么是调停者模式？

在调停者模式中，所有的成员对象都可以协调工作，但是又不直接相互管理。这些对象都与一个处于中心地位的协调者对象发生紧密的关系，由这个协调者对象进行协调工作。
这个协调者对象叫做调停者(Mediator)，而调停者所协调的成员对象称作同事(Colleague)对象。
在Clolleague对象内部发生的事件会影响到所有的同事，但是这种影响不是以直接管理的方式直接传到其他对象上的。
如果小组的成员增加时，调停者对象可能会面临修改，而其他的同事则可以装作不知道这个新的成员一样，不必修改。
反过来，如果小组的成员之一从系统中被删除掉的话，调停者对象需要对此作出修改，而小组中的其他的同事则不必改动。


调停者模式包括以下几种角色：
抽象调停者(Mediator)角色、具体调停者(ConcreteMediator)角色、抽象同事类(AbstractColleague)角色、具体同事类(ConcreteColleague)角色。


调停者模式的优点
1，可以避免同事对象之间的过度耦合，使得调停者与同事类可以相对独立的演化。
2，将多对多的相互作用转化为一对多的相互作用，使得对象之间的关系更加易于维护和理解。

调停者模式的缺点
1，降低了同事对象的复杂性，代价是增加了调停者类的复杂性。当然，在很多情况下，设置一个调停者未必比不设置它更好。
2，调停者类经常充满了各个具体同事类的关系协调代码，这种代码常常是不能复用的。因此，具体同事类的复用是以调停者类的不可复用为代价的。

显然，调停者模式为同事对象，而不是调停者对象提供了可扩展性，所以这个模式所提供的可扩展性是一种(向同事对象)倾斜的可扩展性。


JDK里的应用：

java.util.Timer
java.util.concurrent.Executor#execute()
java.util.concurrent.ExecutorService#submit()
java.lang.reflect.Method#invoke()