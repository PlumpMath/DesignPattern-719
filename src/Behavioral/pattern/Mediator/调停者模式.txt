                                                                               调停者(Mediator)模式

调停者模式是对象的行为模式。
调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用，从而使它们可以较松散的耦合。
当这些对象中的某些对象之间的相互作用发生改变时，不会立即影响到其他的一些对象之间的相互作用，从而保证这些相互作用可以彼此独立的变化。


为什么需要调停者模式？

如图 对象关系图1.PNG 所示，这个系统里面有大量的对象，这些对象既会影响别的对象，又会被别的对象影响，因此常常叫做同事(Colleague)对象。
这些同事对象通过彼此的相互作用形成系统的行为。
从图中可以看出，几乎每一个对象都需要与其他的对象发生相互作用，而这种相互作用表现为一个对象与另一个对象的直接耦合。这是一个过度耦合的系统。
通过引入调停者对象(Mediator)，可以将系统的网状结构变成以调停者为中心的形状结构，如图 对象关系图2.PNG 所示。
在这个系统中，同事对象不再通过直接的联系与另一个对象发生相互作用；相反地，它通过调停者对象与另一个对象发生相互作用。
调停者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入造成大量的修改工作。
面向对象技术可以更好的协助设计师管理更为复杂的系统。
一个好的面向对象的设计可以使对象之间增加协作性(Collaboration)，减少耦合度(Coupling)。
一个深思熟虑的设计会把一个系统分解为一群相互协作的同事对象，然后给每一个同事对象以独特的责任，恰当的设置它们之间的协作关系，使它们可以在一起工作。


对行为的封装

一个对象所封装的是它的行为，而面向对象设计的中心问题是如何体现系统的行为。
因为一个系统的行为不仅仅存在于一个对象里面，而是同时存在于很多对象里面，并且存在于这些对象之间的相互作用之中。
因此，一个设计恰当的体现系统的行为并不是一个容易的问题。
一个对象往往要与几个对象发生相互作用，就好比在一个小组中工作的人一样，每一个人都要与其他的同事发生相互作用。
这时，一个直截了当的、不好的设计会把这些与其他的对象直接固定到每一个对象里面。
这样做的结果自然是使这些对象独立演化的难度增加，使每一个对象的变化都会影响到所有与之发生相互作用的对象。
这就好比每一个在小组中工作的人都要成为其他人的经理，不仅要管理自己，还要管理所有的同事。
在现实世界里，没有一个小组能再这样过度耦合的组织结构中完成任何事情。
如果一个小组只有三个人，那么三个人之间会有三个相互关系；
而如果小组的规模扩大到五个人时，这种相互作用关系就增加到十个，增长的速度是组合数级的，比指数级还要快。
在实际工作中，一个有效的管理制度是给这个小组配备一个小组长，负责协调小组成员之间的关系，小组的同事通过小组长可以形成整个小组的行为。
这实际上就是调停者模式的应用。


什么是调停者模式？

在调停者模式中，所有的成员对象都可以协调工作，但是又不直接相互管理。
这些对象都与一个处于中心地位的协调者对象发生紧密的关系，由这个协调者对象进行协调工作。
这个协调者对象叫做调停者(Mediator)，而调停者所协调的成员对象称作同事(Colleague)对象。
在Clolleague对象内部发生的事件会影响到所有的同事，但是这种影响不是以直接管理的方式直接传到其他对象上的。
记住在小组的成员增加时，这样的相互作用关系是以比指数更快的方式增加的。
相反，这种影响仅仅直接影响到调停者对象，而调停者对象反过来会协调其他的同事，形成整个系统的行为。
如果小组的成员增加时，调停者对象可能会面临修改，而其他的同事则可以装作不知道这个新的成员一样，不必修改。
反过来，如果小组的成员之一从系统中被删除掉的话，调停者对象需要对此作出修改，而小组中的其他的同事则不必改动。


迪米特法则

迪米特法则要求每一个对象与其他对象的相互作用均是短程的，而不是长程的。
而且只要可能，朋友的数目越少越好。换言之，一个对象只应当知道它的直接合作者的接口。
调停者模式创造出一个调停者对象，将系统中有关的对象所引用的其他对象数目减到最少，使得一个对象与其同事的相互作用被这个对象与调停者对象的相互作用所取代。
显然，调停者模式是迪米特法则的一个具体应用。


调停者模式包括以下几种角色：
抽象调停者(Mediator)角色、具体调停者(ConcreteMediator)角色、抽象同事类(AbstractColleague)角色、具体同事类(ConcreteColleague)角色。


调停者模式的优点
1，可以较少使用静态的继承关系，使得具体同事类可以更加容易的被复用。
2，可以避免同事对象之间的过度耦合，使得调停者与同事类可以相对独立的演化。
3，将多对多的相互作用转化为一对多的相互作用，使得对象之间的关系更加易于维护和理解。
4，将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。

调停者模式的缺点
1，降低了同事对象的复杂性，代价是增加了调停者类的复杂性。当然，在很多情况下，设置一个调停者未必比不设置它更好。
2，调停者类经常充满了各个具体同事类的关系协调代码，这种代码常常是不能复用的。因此，具体同事类的复用是以调停者类的不可复用为代价的。

显然，调停者模式为同事对象，而不是调停者对象提供了可扩展性，所以这个模式所提供的可扩展性是一种(向同事对象)倾斜的可扩展性。


调停者模式是一个很容易被滥用的模式，什么情况下不应当使用调停者模式？

1，不应当在责任划分混乱时使用
设计师在对面向对象技术不熟悉时，会是一个系统在责任的分割上发生混乱。
责任分割的混乱会使得系统中的对象与对象之间产生不适当的复杂关系。
这时候，一个很糟的想法就是继续这个错误，并使用调停者模式来化解这一团乱麻。
实际上这样一来，责任错误划分的混乱不但不会得到改正，而且还会制造出一个莫名其妙的怪物：一个处于一团乱麻之中的混乱之首。

2，不应当对数据类和方法类使用
设计师常常会设计出这样的一种系统：让一系列类只含有数据，另一些只含有方法。
比如，描述一个客户时，这些设计师首先设计出一个叫客户数据的类，只含有客户数据，
另外再设计一个类叫做管理类，含有操作客户以及客户购买公司产品、付账的方法。
管理类自然会涉及到其他的类，诸如产品数据类、订单数据类等。
如此一来，管理类就变成一个操作所有的数据类的方法类。
这是很没道理的设计，并不是调停者模式的应用。
要正确理解封装，封装首先是行为，以及行为所涉及的状态的封装。行为与状态是不应当分隔开来的。
调停者模式的用途是管理很多的对象的相互作用，以便使这些对象可以专注于自身的行为，而独立于其他的对象。
上面的管理类则不同，因为它把一个数据对象的内部状态取出来，在运算后，再插入到另一个数据对象里面。
这些数据对象根本没有包装任何的行为，是被动的行为接收者。显然，这与调停者模式根本不相干。
正确的做法是让每一个类对自己的行为负责，纯数据类的划分是完全没有道理的。


JDK里的应用：

java.util.Timer
java.util.concurrent.Executor#execute()
java.util.concurrent.ExecutorService#submit()
java.lang.reflect.Method#invoke()