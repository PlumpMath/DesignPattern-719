                                                                                                            迭代子(Iterator)模式

迭代子模式又叫游标(Cursor)模式，是对象的行为模式。
迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。

聚集：多个对象聚在一起形成的总体。聚集对象是能够包容一组对象的容器对象。
聚集依赖于聚集结构的抽象化，具有复杂性和多样性。JDK的JCF框架就是聚集的实现。


为什么聚集需要迭代子？

聚集对象必须提供适当的方法，允许客户端能够按照一个线性顺序遍历所有的元素对象，把元素对象提取出来或者删除掉等。
一个使用聚集的系统必然会使用这些方法操控聚集对象，因而在使用聚集的系统演化过程中，会出现两类问题：

1，迭代逻辑没有改变，但是需要将一种聚集换成另一种聚集。
因为不同的聚集具有不同的遍历接口，所以需要修改客户端代码，以便将已有的迭代调用换成新聚集对象所要求的接口。

2，聚集不会改变，但是迭代方式需要改变。
比如原来只需要读取元素和删除元素，但现在需要增加新的元素；
或者原来的迭代仅仅遍历所有的元素，而现在则需要对元素加以过滤等。
这时就只好修改聚集对象，修改已有的遍历方法，或者增加新的方法。

显然，出现这种情况是因为所涉及的聚集设计不符合开闭原则，也就是因为没有将不变的结构从系统中抽象出来，
与可变成分分割，并将可变部分的各种实现封装起来。
一个聪明的做法是应当使用更加抽象的处理方法，使得在进行迭代时，客户端根本无需知道所使用的聚集是哪种类型；
而当客户端需要使用全新的迭代逻辑时，只需引进一个新的迭代子对象即可，根本无需修改聚集对象本身。

迭代子模式便是这样的一个抽象化的概念。
这一模式之所以能做到这一点，是因为它将迭代逻辑封装到一个独立的迭代子对象中，从而与聚集本身分割开。
迭代子对象是对遍历的抽象化，不同的聚集对象可以提供相同的迭代子对象，从而使客户端无需知道聚集的底层结构。
一个聚集可以提供多个不同的迭代子对象，从而使得遍历逻辑的变化不会影响到聚集对象本身。


迭代子模式和开闭原则

开闭原则要求系统可以在不修改已有代码的情况下进行功能的扩展，做到这一点的途径就是对变化的封装。
从对变化的封装角度讲，迭代子模式将访问聚集元素的逻辑封装起来，并且使它独立于聚集对象的封装。
这就是提供了聚集存储逻辑与迭代逻辑独立演变的空间，增加了系统的可复用性，可以使系统具有在无需修改的情况下进行扩展的能力。
从代码重构的角度上讲，迭代子在客户端和聚集之间增加一个中介层，从而使得客户端与聚集之间的通信从直接变成间接。
这样做的好处就是缓冲了客户端的变化对聚集的影响，以及聚集的变化对客户端的影响。

按照迭代的方向，迭代可以分为两种：正向迭代(Forward Iteration)和逆向迭代(Backward Iteration)。

迭代子模式涉及到以下几种角色：
抽象迭代子(Iterator)角色、具体迭代子(ConcreteIterator)角色、聚集(Aggregate)角色、具体聚集(ConcreteAggregate)角色。


迭代子模式的优点

1，迭代子模式简化了聚集的界面。迭代子具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。

2，每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。
因此，一个聚集对象可以同时有几个迭代在进行之中。

3，由于遍历算法被封装在迭代子角色里面，因此迭代的算法可以独立于聚集角色变化。
由于客户端拿到的是一个迭代子对象，因此，不必知道聚集对象的类型，就可以读取和遍历聚集对象。
这样即便聚集对象的类型发生变化，也不会影响到客户端的遍历过程。


迭代子模式的缺点

1，迭代子模式给客户端一个聚集被顺序化的错觉，因为大多数的情况下聚集的元素并没有确定的顺序，但是迭代必须以一定线性顺序进行。
如果客户端误以为顺序是聚集本身具有的特性而过度依赖于聚集元素的顺序，很可能得到错误的结果。

2，迭代子给出的聚集元素没有类型特征。
一般而言，迭代子给出的元素都是Object类型，因此，客户端必须具备这些元素类型的知识才能使用这些元素。
Java的泛型应该可以克服这个缺点了。