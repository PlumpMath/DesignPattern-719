                                                                      责任链(Chain Of Responsibility)模式

责任链模式属于对象的行为模式。
在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。
请求在这个链上传递，直到链上的某一个对象决定处理此请求。
发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，
这使得系统可以在不影响客户端的情况下动态的重新组织链和分配责任。

责任链模式涉及到的角色有：抽象处理者(Handler)角色、具体处理者(ConcreteHandler)角色。

在下面的情况下可以使用责任链模式：

1，系统已经有一个由处理者对象组成的链。这个链可能由合成模式给出。

2，有多于一个的处理者对象会处理一个请求，而且事先并不知道到底由哪一个处理者对象处理一个请求。这个处理者对象是动态确定的。

3，系统想发出一个请求给多个处理者对象中的某一个，但是不明显指定是哪一个处理者对象会处理此请求。

4，处理一个请求的处理者对象集合需要动态地指定时。


责任链模式降低了发出命令的对象和处理命令的对象之间的耦合，
它允许多于一个的处理者对象根据自己的逻辑来决定哪一个处理者最终处理这个命令。
换言之，发出命令的对象只是把命令传给链结构的起始者，而不需要知道到底是链上的哪一个节点处理了这个命令。
这意味着在处理命令时，允许系统有更多的灵活性。
哪一个对象最终处理一个命令可以因为由哪些对象参加责任链，以及这些对象在责任链上的位置不同而有所不同。


链结构的由来

值得指出的是，责任链模式并不创建出责任链。责任链的创建必须由系统的其他部分创建出来。
责任链模式减低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。
一个链可以是一条线，一个树，也可以是一个环。链的拓扑结构可以是单连通的或多连通的，责任链模式并不指定责任链的拓扑结构。
但是责任链模式要求在同一个时间里，命令只可以被传给一个下家(或被处理掉)，而不可以传给多于一个下家。
责任链的具体处理者对象可以是同一个具体处理者类的实例。


命令的传递

在一个责任链上传递的可能不只有一个命令，而是数个命令。
这些命令可以采取抽象化层、具体化层的多态性实现方式。
从而可以将命令对象与责任链上的对象之间的责任分隔开，并将命令对象与传播命令的对象分隔开。