                                       访问者(Visitor)模式

访问者模式属于对象的行为模式。
它的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构则可以保持不变。

访问者模式适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。
数据结构的每一个节点都可以接受一个访问者的调用，此节点向访问者对象传入节点对象，而访问者对象则反过来执行节点对象的操作。
这样的过程叫做“双重分派”。节点调用访问者，将它自己传入，访问者则将某算法针对此节点执行。

访问者模式涉及到的角色：
抽象访问者(Visitor)角色、具体访问者(ConcreteVisitor)角色、抽象节点(Node)角色、具体节点(ConcreteNode)角色、结构对象(ObjectStructure)角色。

访问者模式的适用性

1，倾斜的可扩展性
访问者模式应当在被访问的类结构非常稳定的情况下使用。换言之，系统很少出线需要加入新节点的情况。
如果出现需要加入新节点的情况，那就必须在每一个访问者对象中加入一个对应于这个新节点的访问操作
(也就是在访问者接口中增加一个新方法)，而这是对系统的大规模修改。因而是违背开闭原则的。
访问者模式允许在节点中加入新的方法，相应的仅仅需要在一个新的访问者类中加入此方法
(如果访问者类确实需要调用此方法)，而不需要在每一个访问者类中都加入此方法。
显然，访问者模式提供了倾斜的可扩展性设计：方法集合的可扩展性和类集合的不可扩展性。

2，如果系统的数据结构是频繁变化的，则不适合使用访问者模式。
很多系统可以按照算法和数据结构分开，也就是说一些对象含有算法，另一些对象含有数据，接受算法的操作。
如果这样的系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使得算法操作的增加变得容易。
反过来，如果这个系统的数据结构对象易于变化，经常要有新的数据对象增加进来的话，就不适合使用访问者模式了。


访问者模式的优点
1，它使得增加新的操作变得很容易。
如果一些操作依赖于一个复杂的结构对象的话，那么一般而言，增加新的操作会很复杂。
而使用访问者模式，增加新的操作意味着增加一个新的访问者类，因此比较容易。
2，它将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。
3，它可以跨过几个类等级结构访问属于不同类等级结构的成员类(因为这些互不相关的类都要实现可被访问接口，即声明accept()方法的接口)。
迭代子只能访问属于同一类等级结构的成员对象。而不能访问属于不同类等级结构的对象。
4，积累状态。
每一个单独的访问者对象都集中了相关的行为，从而也就可以在访问的过程中将执行操作的状态积累在自己内部，而不是分散到很多节点对象中。这是有益于系统维护的优点。


访问者模式的缺点
1，增加新的节点类变得很困难。
每增加一个新的节点都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作。
2，破坏封装。
访问者模式要求访问者对象访问并调用每一个节点对象的操作，这隐含了一个对所有节点对象的要求：
它们必须暴露一些自己的操作和内部状态。不然，访问者的访问就变得没有意义。
由于访问者对象自己会积累访问操作所需的状态，从而使这些状态不再存储在节点对象中，这也是破坏封装的。

由于明显的缺点，访问者模式成为了一个有争议的设计模式。


访问者模式的实现
1，谁负责遍历行为
由于每一个访问者都需要访问结构对象中的每一个元素，因此，一个自然的问题就是，哪一个角色负责遍历行为？
可供选择的有：结构对象(ObjectStructure)、访问者对象或者创建一个新的迭代对象。
a,由结构对象负责迭代是最常见的选择，这也就是需要结构对象的出发点。
b,另一个解决方案是使用一个迭代对象来负责遍历行为。
c,将遍历行为放到访问者中是第三个可能的选择。
一般而言，这样做会导致每一个具体访问者都不得不具有管理聚集的内部功能，而这在一般情况下是不理想的。
然而如果遍历的逻辑较为复杂的话，将所有的遍历逻辑放到结构对象角色中，不如将逻辑放到各个具体访问者角色中，因此这种做法也不失为一种可行的选择。

2，是否需要结构对象角色
如果遍历行为是放到具体访问者中的，那么结构对象就可以省略了。

3，是否需要抽象访问者角色
如果非常肯定访问者只有一个，那么设置抽象访问者角色便没有太大意义，完全可以忽略。

































