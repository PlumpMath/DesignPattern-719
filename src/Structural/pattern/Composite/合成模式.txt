                                 合成(Composite)模式

合成模式属于对象的结构模式，又叫做部分-整体(Part-Whole)模式。
合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。
合成模式可以使客户端将单纯元素与复合元素同等看待。


树的知识

一个树结构由两种节点组成：树枝节点和树叶节点。树枝节点可以有子节点，而一个树叶节点不可以有子节点。
一个树枝节点可以不带任何叶子，但是因为有带有叶子节点的能力，因此仍然是树枝节点，而不会成为树叶节点。
一个树叶节点则永远不可能带有子节点。在信息系统中，树枝节点所代表的构件常常用作树叶节点所代表的构建的容器。
一个树结构中总有至少一个节点是特殊的节点，称作根节点。一个根节点没有父节点，因为它是树结构的根。
一般讨论的树都是只有一个根节点的树。一个树的根节点一般是树枝节点，如果根节点是树叶节点的话，这个树就变成了只有这一个节点的树。


合成模式把部分和整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由它们复合而成的的合成对象同等看待。
比如文件系统就是一个典型的合成模式系统：
文件系统是一个树结构，树上长有节点。树的节点有两种：一种是树枝节点，即目录，有内部树结构；另一种是文件，即树叶节点，没有内部树结构。
显然可以把目录和文件当做同一种对象同等对待和处理，这也就是合成模式的应用。


合成模式结构涉及三个角色：

抽象构件(Component)角色：
这是一个抽象角色，它给参加组合的对象定义出公共的接口及其默认行为。

树叶构件(Leaf)角色：
代表参加组合的树叶对象。一个树叶没有下级的子对象。定义出参加组合的原始对象的行为。

树枝构件(Composite)角色：
代表参加组合的有子对象的对象，并给出树枝构件对象的行为。

Composite类型的对象含有其他的Component类型的对象，换言之，Composite类型的对象可以含有其他的树枝(Composite)类型或树叶(Leaf)类型的对象。

合成模式的实现根据所实现的接口的区别分为两种形式：安全式和透明式。虽然这是模式的实现问题，但是它影响到了模式结构的细节。
合成模式可以不提供父对象的管理方法，但是必须在合适的地方提供子对象的管理方法。
在什么地方声明子对象的管理方法，诸如add()、remove()以及getChild()等就变成了一个值的仔细思考的问题。

安全式

实现方式：
在Composite类里面声明所有的用来管理子类对象的方法。这样的做法是安全的做法，因为树叶对象根本就没有管理子类对象的方法。

因此(优点：)如果客户端对树叶对象使用这些方法时，程序会在编译阶段出错。

缺点：
对客户端不够透明，是因为树叶类和树枝类将具有不同的接口。

透明式

实现方式：
在Component里面生命所有的用来管理子类对象的方法，包括add()、remove()以及getChild()方法。

优点：
所有的构建类都有相同的接口。在客户端看来，树叶对象和树枝对象的区别起码在接口层次上消失了，客户端可以同等的对待所有的对象。所以称之为透明式。

缺点：
不够安全，因为树叶对象和树枝对象在本质上是有区别的。
树叶对象不可能有下一个层次的对象，因此add()、remove()以及getChild()方法没有意义，但是在编译阶段不会出错，而只会在运行阶段才会出错。


在下面的情况下应当考虑使用合成模式：
1，需要描述对象各部分和整体的等级结构。
2，需要客户端忽略掉个体构件和组合构件的区别。客户端必须平等对待所有的构件，包括个体构件和组合构件。

合成模式的优点：
1，合成模式可以很容易的增加新种类的构件。
2，使用合成模式可以使客户端变得很容易设计，因为客户端不需要知道构件是树叶构件还是树枝构件。

合成模式的缺点：
1，使用合成模式后，控制树枝构件的类型就不太容易。
2，用继承的方法来增加新的行为很困难。


JDK里的应用：

javax.swing.JComponent#add(Component)
java.awt.Container#add(Component)
java.util.Map#putAll(Map)
java.util.List#addAll(Collection)
java.util.Set#addAll(Collection)