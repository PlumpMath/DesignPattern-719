                         装饰模式和适配器模式

装饰模式和适配器模式都是包装(Wrapper)模式，它们都是通过封装其他对象达到设计目的的，但是它们的形态有很大区别。

它们之间的区别是，适配器模式把一个API转换成另一个API，而装饰模式是保持被包装的对象的API。
用Java属于来讲，适配器和被适配的类实现的是不同的接口和抽象类，而装饰模式和被装饰的类实现的是相同的接口和抽象类。

理想的装饰模式在对被装饰对象进行功能增强的同时，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。
而适配器模式则不然，适配器模式并不要求对源对象的功能进行增强，但是会改变源对象的接口，以便和目标接口相符合。

装饰模式有透明和半透明两种，这两种的区别就在于装饰角色的接口与抽象构件角色的接口是否完全一致。
透明的装饰模式也就是理想的装饰模式，要求具体构件角色、装饰角色的接口与抽象构件角色的接口完全一致。
相反，如果装饰角色的接口与抽象构件角色接口不一致，也就是说装饰角色的接口比抽象构件角色的接口宽的话，
装饰角色实际上已经成了一个适配器角色，也称为半透明的装饰模式。如下图所示：

     装饰模式     <---    半透明的装饰模式    --->     适配器模式
(增强功能，不改变接口)  (增强功能，改变接口)      (改变接口，不改变功能)
<------透明---------------------------------------不透明------>

在适配器模式里面，适配器类的接口通常会与目标类的接口重叠，但往往并不完全相同。换言之，适配器类的接口会比被装饰的目标类的接口宽。

显然，半透明的装饰模式实际上就是处在适配器模式与装饰模式之间的灰色地带。纯粹的装饰模式在真实的系统中很难找到。
一般所遇到的都是这种半透明的(退化的)装饰模式。一般而言，对一个对象进行功能增强，都会导致加入新的行为。
因此，装饰角色的接口比抽象构件角色的接口宽是很难避免的。BufferedReader是属于Reader类型的输入流处理器，
这个流处理器的功能是给流的处理增加缓冲功能，它提供了按行读入的功能，这就是readLine()方法，而这个方法在Reader接口里并没有。

一个装饰类实现的新方法越多，它离纯装饰类的距离也就越远，离适配器模式的距离也就越近。
