                              装饰(Decorator)模式

装饰模式又名包装(Wrapper)模式。
装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

装饰模式中的角色有：
抽象构件(Component)角色、具体构件(ConcreteComponent)角色、装饰(Decorator)角色、具体装饰(ConcreteDecorator)角色。

在以下情况下应当使用装饰模式：
1，需要扩展一个类的功能，或给一个类增加附加责任。
2，需要动态的给一个对象增加功能，这些功能可以再动态地撤销。
3，需要增加由一些基本功能的排列组合而产生的非常大量的功能，从而使继承关系变得不现实。


装饰模式的优缺点：
1，装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。
装饰模式允许系统动态的决定贴上一个需要的“装饰”，或者除掉一个不需要的“装饰”。
继承关系则不同，继承关系是静态的，它在系统运行前就决定了。
2，通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。
3，这种比继承更加灵活机动的特性，也同时意味着装饰模式比继承更加易于出错。
不同的装饰类在排列组合时会产生不合理的或荒谬的组合，或是制造出循环引用的错误来。
4，由于使用装饰模式可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。
但是，另一方面，使用装饰模式会产生比使用继承关系更多的对象。
更多的对象会使得差错变得困难，特别是这些对象看上去都很相像。


JDK里的应用：

java.io.BufferedInputStream(InputStream)
java.io.DataInputStream(InputStream)
java.io.BufferedOutputStream(OutputStream)
java.util.zip.ZipOutputStream(OutputStream)
java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()
