                                                                             门面(Facade)模式

门面模式是对象的结构模式。
为子系统中的一组接口提供一个一致的门面，Facade模式定义了一个高层接口，这个接口使得这一子系统(被客户端)更加容易使用。


子系统的客户端

处理复杂系统的一个常用方法便是将其"分而治之"，把一个系统划分为几个较小的子系统。但是这样做了之后，往往会发现一个子系统内仍然有太多的类要处理。
而使用一个子系统的客户端往往只关注一些特定的功能，需要同时与子系统内部的许多对象打交道后才能达到目的，其对象图见 原始子系统对象图.PNG。
这就是一种不便，它使得系统的逻辑变得不必要的复杂，维护成本提高，复用率降低。


门面模式要求一个子系统的外部与其内部的通信必须通过一个统一的门面(Facade)对象进行。它提供一个高层次的接口，使得子系统更易于使用，其对象图见 使用门面模式的子系统对象图.PNG。
门面模式的门面对象将客户端与子系统的内部复杂性分隔开，使得客户端只需要与门面对象打交道，而不需要与子系统内部的很多对象打交道。


门面模式的结构

门面模式没有一个一般化的类图描述，示意性类图见 门面模式示意性类图.PNG。模式涉及的角色有门面(Facade)角色、子系统(Subsystem)角色。


一个系统可以有几个门面类

在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类（或拥有很多静态方法的工具类）。
当然这并不意味着在整个系统里只能有一个门面类，而仅仅是说对每一个子系统只有一个门面类。
或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。

门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。
如果一个门面模式不能将子系统的所有的行为提供给外界，那么可以通过修改门面类或者继承门面类的办法，使门面类或其子类能够将子系统的行为提供给外界。
但是，如果一个子系统没有某个行为，想通过修改门面类或者继承门面类的办法来提供这个新的行为是错误的。


门面模式的适用性

1，为一个复杂子系统提供一个简单接口
子系统往往因为不断演化而变得越来越发杂，使用门面模式可以使得子系统更具可复用性。
它可以提供一个简单的默认视图，对大多数用户来说这个视图已经足够用了，而那些需要进一步继承的用户可以越过Facade层直接对子系统进行继承。

2，子系统的独立性
一般而言，子系统和其他的子系统之间、客户端与实现层之间存在很大的依赖性。
引入Facade模式将一个子系统与它的客户端以及其他的子系统分离，可以提高子系统的独立性和可移植性。

3，层次化结构
在构建一个层次化的系统时，可以使用Facade模式定义系统每一层的入口。
如果层与层之间是相互依赖的，则可以限定它们仅通过Facade进行通信，从而简化了层与层之间的依赖关系。


门面模式创造出一个门面对象，将客户端所涉及的属于一个子系统的协作伙伴的数目减少到最少，使得客户端与子系统内部的对象的相互作用被门面对象所取代。
显然，门面模式就是实现代码重构以便达到迪米特法则要求的一个强有力的武器。


JDK里的应用：

java.lang.Class
javax.faces.webapp.FacesServlet
