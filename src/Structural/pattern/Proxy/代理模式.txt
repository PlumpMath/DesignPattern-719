                                                                                 代理(Proxy)模式

代理模式是对象的结构模式。
代理模式给某一个对象的提供一个代理对象，并由代理对象控制对真正对象的引用。


间接通信的思想

间接性的通信可以给出较低的耦合关系，较强的合作关系，以及微妙的结构和易于复用的设计架构。

假设一个系统已经有一个对象A。现在需要向这个系统加入一个新的对象C。
对象C需要使用系统中已有的对象A，但是C不能像系统现在使用A这样使用A，要么是A提供的接口不符合C的要求，要么是A的功能需要进一步加强等。
设计师可以选择修改对象A，也可以选择使用一个中介对象B，让对象B将调用传递给对象A。
这样新的对象C便不必直接与系统中已有的对象A打交道，而是通过中介对象B与A打交道；
而对象B则可以利用这一有利位置为对象C提供一个与A完全不同的接口，或者做一些A本来不做的操作。

适配器模式就是间接通信思想的体现，装饰模式也是一个利用了中间对象来增强对象功能的模式，
但是这两种模式并不是唯一强调通信间接化的模式。还有一种利用间接通信改善系统设计的模式――代理模式。


所谓代理，就是一个人或者一个机构代表另一个人或者另一个机构采取行动。
在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。


代理的种类

按照使用目的来划分，代理有以下几种：
1，远程(Remote)代理
2，虚拟(Virtual)代理
3，Copy-on-Write代理
4，保护(Protection Access)代理
5，Cache代理
6，防火墙(Firewall)代理
保护目标，不让恶意用户接近。
7，同步化(Synchronization)代理
8，智能引用(Smart Reference)代理

Windows中的快捷方式就是代理的一个例子。


代理模式中的角色有：
抽象主题角色、代理主题(Proxy)角色、真实主题角色。


与客户端直接向真实主题发出请求的情况相比，使用代理主题的显著好处是，系统提供了向真实主题传递客户端请求的控制。
代理主题可以在向真实主题传递客户端请求之前执行特定的操作，并决定是否将请求传递给真实主题；
代理主题可以在向真实主题传递客户端请求之后执行另外一种操作，比如将客户端请求计数等。
客户端有可能根本没有直接向真实主题提出请求的许可(不具有直接调用真实主题方法的权限)，
而代理主题具有这种许可(直接调用真实主题方法的权限)，因此，代理主题可以在执行preRequest()操作后决定是否再传递请求。
总之，代理模式将一个中间层插入到客户端和主题角色之间，从而提供了许多的灵活性。


JDK里的应用：

java.lang.reflect.Proxy
RMI