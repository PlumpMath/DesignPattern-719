                              适配器(Adapter)模式

适配器(Adapter)模式把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。
它也叫做包装(Wrapper)模式，把已有的一些类包装起来，使之能有满足需要的接口。


适配器模式的用意是将接口不同而功能相同或者相近的两个接口加以转换，
这里面包括适配器角色补充源角色没有的方法，但是目标接口需要的方法。
适配器模式有类的适配器模式和对象的适配器模式两种不同的形式。

类的适配器模式的效果：
1，使用一个具体类把源适配到目标中，这样一来，如果源以及源的子类都使用此类适配就行不通了。
2，由于适配器是源的子类，因此可以在适配器中置换(override)掉源的一些方法。
3，由于只引进了一个适配器类，因此只有一个路线达到目标类，使问题得到简化。

对象的适配器模式的效果：
1，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类及其子类都适配到目标接口。
2，与类的适配器模式相比，要想置换源类的方法就不容易。
如果一定要置换掉源类的一个或多个方法，就只好先做一个源类的子类，将源类的方法置换掉，然后再把源类的子类当做真正的源进行适配。
3，虽然想要置换源类的方法不容易，但是适配器类要想增加一些新的方法则方便得很，而且新增加的方法可同时适用于所有的源。


在以下各种情况下使用适配器模式：
1，系统需要使用现有的类，而此类的接口不符合系统的需要。
2，想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关系的一些类，
包括一些可能在将来引进的类一起工作。这些源类不一定有很复杂的接口。
3，对对象的适配器模式而言，在设计里，需要改变多个已有的子类的接口，
如果使用类的适配器模式，就要针对每一个子类做一个适配器类，而这不太实际。


本模式在实现时有以下这些值得注意的地方：
1，目标接口可以省略。此时目标接口和源接口实际上是相同的。
由于源是一个接口，而适配器类是一个类，因此这种做法看似平庸而并不平庸，
它可以使客户端不必实现不需要的方法。这一点将在缺省适配模式中做详尽的分析。
2，适配器类可以是抽象类。这可以在缺省适配的情况下看到。
3，带参数的适配器模式。使用这种方法，适配器类可以根据参数返还一个合适的实例给客户端。


JDK里的应用：

java.util.Arrays#asList()
javax.swing.JTable(TableModel)
java.io.InputStreamReader(InputStream)
java.io.OutputStreamWriter(OutputStream)
javax.xml.bind.annotation.adapters.XmlAdapter#marshal()
javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()