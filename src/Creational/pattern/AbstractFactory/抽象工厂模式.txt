                              抽象工厂(Abstract Factory)模式

抽象工厂模式是所有形态的工厂模式中最为抽象和具有一般性的一种形态。它是对象的创建模式，是工厂方法模式的进一步推广。
它的简略类图见 抽象工厂类图快照.PNG，图中左边的等级结构代表工厂等级结构，右边的两个等级结构分别代表不同的产品的等级结构。
抽象工厂模式的用意是可以向客户端提供一个接口，使得客户端在不必指定产品的具体类型的情况下，创建多个产品族中的产品对象。


产生背景

抽象工厂模式面对的问题是多个产品等级结构的系统设计。
抽象工厂模式与工厂方法模式最大的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构。

产品族(Product Family)：指位于不同产品等级结构中，功能相关联的产品组成的家族。
每一个产品族含有产品的数目，与产品等级结构的数目是相等的。

如图 平行的多等级结构.PNG，右边是三个不同的等级结构，它们具有平行的结构。
如果采用工厂方法模式，就势必要使用三个独立的工厂等级结构来对付这三个产品等级结构。
由于这三个产品等级结构的相似性，会导致三个平行的工厂等级结构。
随着产品等级结构的数目的增加，工厂方法模式所给出的工厂等级结构的数目也会随之增加。
这里可以只使用一个工厂等级结构来对付这些相同或者极为相似的产品等级结构，同一个工厂等级结构负责三个不同产品等级结构中的产品对象的创建。
也就是说一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象。这时候抽象工厂模式比工厂方法模式更有效率。


应用场景

在以下情况下应当考虑使用抽象工厂模式：
1，一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有形态的工厂模式都是重要的。
2，这个系统的产品有多于一个的产品族，而系统只消费其中某一族的产品，这是抽象工厂模式的原始用意
(在现代的应用中，抽象工厂模式的使用范围已经大大扩大了，不再要求系统只能消费某一个产品族了)。这条可以不必理会。
3，同属于同一个产品族的产品是在一起使用的，这一约束必须在系统的设计中体现出来。
4，系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于实现。


对 开闭原则 的支持

开闭原则要求一个软件系统可以在不修改原有代码的情况下，通过扩展达到增强其功能的目的。
对于一个涉及到多个产品等级结构和多个产品族的系统，其功能的增强不外乎两个方面：

1，增加新的产品族

在产品等级结构的数目不变的情况下，增加新的产品族，就意味着在每一个产品等级结构中增加一个或者多个新的具体产品角色。
由于工厂等级结构是与产品等级结构平行的等级结构，因此，当产品等级结构有所调整时，需要将工厂等级结构做相应的调整。
现在产品等级结构中出现了闲的元素，因此需要向工厂等级结构中加入相应的新元素就可以了。
也就是说只需要向系统中加入新的具体工厂类就可以了，没有必要修改已有的工厂角色或者产品角色。
因此，在系统中的产品族增加时，抽象工厂模式是支持开闭原则的。

2，增加新的产品等级结构

在产品族的数目不变的情况下，增加新的产品等级结构。也就是说，所有的产品等级结构中的产品数目不会改变，
但是现在多出一个与现有的产品等级结构平行的新的产品等级结构。
要做到这一点，就需要修改所有的工厂角色，给每一个工厂类都增加一个新的工厂方法，而这显然违背了开闭原则。
因此，对于产品等级结构的增加，抽象工厂模式是不支持开闭原则的。

综合来说，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，而不能为新的产品等级结构的增加提供方便。


JDK里的应用：

java.util.Calendar#getInstance()
java.util.Arrays#asList()
java.util.ResourceBundle#getBundle()
java.sql.DriverManager#getConnection()
java.sql.Connection#createStatement()
java.sql.Statement#executeQuery()
java.text.NumberFormat#getInstance()
javax.xml.transform.TransformerFactory#newInstance()