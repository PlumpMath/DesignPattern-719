                              原型(Prototype)模式

原型模式属于对象的创建模式。
通过给出一个原型对象来指明所要创建的对象的类型，然后用赋值这个原型对象的方法创建出更多同类型的对象。这就是原型模式的用意。


再论变量、对象以及对象的引用

在Java语言中，对象就是类的实例。在一般情况下，当把一个类实例化时，此类的所有成员，包括变量和方法，
都被复制到属于此数据类型的一个新的实例中去。比如：

Panda panda = new Panda();

上面的语句做了如下的事情：
1，创建了一个Panda类型的变量，称为panda。
2，创建了一个Panda类的对象。
3，使变量panda指向这个新的对象。

可以将上面的语句分成两个步骤：

Panda panda;
panda = new Panda();

可以看到，第一行建立了一个变量panda，可以指向Panda类对象上。
但在第一行结束时并没有指到Panda对象上(实际上指向null)，只是在第二行才真正指向了一个Panda对象。
因此，对象的创建和对它们的引用是独立的。


原型模式的适用范围

假设一个系统的产品类是动态加载的，而且产品类具有一定的等级结构。
这个时候如果采取工厂模式的话，工厂类就不得不具有一个相应的等级结构。
而产品类的等级结构一旦变化，工厂类的等级结构就不得不有一个相应的变化。
这对于产品结构可能会有经常性变化的系统来说，采用工厂模式就有不方便之处。
这时如果采取原型模式，给每一个产品类配备一个克隆方法(大多数时候只需给产品等级结构的根类配备一个克隆方法)，
便可以避免使用工厂模式所带来的具有固定等级结构的工厂类。
这样，一个使用了原型模式的系统和它的产品对象是怎么创建出来的，
以及这些产品对象之间的结构是怎样的，以及这个结构会不会发生变化是没有关系的。


原型模式的优缺点
优点如下：
1，允许动态的增加或减少产品类。由于创建产品类实例的方法是产品类内部具有的，因此，增加新产品对整个结构没有影响。
2，提供简化的创建结构。工厂方法模式常常需要一个与产品类等级结构相同的等级结构，而原型模式就不需要这样。
3，产品类不需要非得有任何事先确定的等级结构，因为原型模式适用于任何的等级结构。

缺点是每一个类都必须配备一个克隆方法。配备克隆方法需要对类的功能进行通盘考虑，
这对于全新的类来说不是很难，而对于已经有的类不一定很容易，
特别是当一个类引用不支持克隆的间接对象，或者引用含有循环结构的时候。