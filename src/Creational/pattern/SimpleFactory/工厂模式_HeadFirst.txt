                                                                                                                                     工厂模式

当使用"new"时，的确是在实例化一个具体类，用的确实是实现，而不是接口，这样的代码绑着具体类会导致代码更脆弱，缺乏弹性。

虽然工厂模式看起来似乎只是把问题搬到了另一个对象罢了，用new创建对象依然存在，
但是把创建对象的代码包装到一个类，当以后实现改变时，只需修改这个类即可。
另外，工厂会有很多客户类，这些客户类中不再会有new创建对象的语句，这就将产品的"实现"和"使用"解耦了。
这也意味着客户在使用对象时，只会依赖于接口，而不是具体类。

所有的工厂模式都用来封装对象的创建。工厂方法模式通过让子类决定该创建的对象是什么来达到将对象创建的过程封装的目的。

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
也就是说抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么，这样客户就从具体的产品中被解耦。

比较

工厂方法提供一个抽象接口创建一个产品，使用继承：把对象的创建委托给子类，子类实现工厂方法来创建对象。

抽象工厂提供一个抽象接口创建一个产品家族，使用对象组合：对象的创建被实现在工厂接口所暴露出来的方法中。

所有的工厂模式都通过减少应用程序和具体类之间的依赖促进松耦合。