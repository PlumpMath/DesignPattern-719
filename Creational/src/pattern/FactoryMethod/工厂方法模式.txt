                        工厂方法(Factory Method)模式

工厂方法模式是类的创建模式，又叫做虚拟构造子模式或者多态性工厂模式。
它的用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。


产生背景

简单工厂模式的优点是允许客户端相对独立于产品创建的过程，并且在系统引入新产品的时候无需修改客户端，也就是说，它在某种程度上支持开闭原则。
它的缺点是对开闭原则的支持不够，因为如果有新的产品加入到系统中去，就需要修改工厂类，将必要的逻辑加入到工厂类中。
工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了多态，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。
在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建的工作交给子类去做。
这个核心类成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。
这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，所以它比简单工厂模式更有优越性。


平行的等级结构

在可以应用工厂方法模式的情形下，一般都会有一个产品的等级结构，有一个甚至多个抽象产品和多个具体产品组成。
当将工厂方法模式应用到这个系统中去的时候，常常采用的一个做法是按照产品的等级结构设计一个同结构的工厂等级结构。
然后由相应的工厂角色创建相应的产品角色，工厂方法模式的应用如图 平行等级结构.PNG 所示，图中虚线代表创建(依赖)关系。


多态性的丧失和模式的退化

工厂方法模式的实现依赖于工厂角色和产品角色的多态性。在有些情况下，这个模式可以出现退化，其特征就是多态性的丧失。

1，工厂方法不一定每一次都返还一个新的对象，但是它所返还的对象一定是它自己创建的，
而不是在一个外部对象里面创建的，然后传入到工厂对象中的。

2，工厂方法返回的应当是抽象类型，而不是具体类型，只有这样才能保证针对产品的多态性，
换言之，调用工厂方法的客户端可以针对抽象编程，依赖于一个抽象产品类型，而不是具体产品类型。
在特殊情况下，工厂方法仅仅返还一个具体产品类型。这个时候工厂方法模式的功能就退化了，表现为针对产品角色的多态性的丧失。
换言之，客户端从工厂方法的静态类型可以得知将要得到的是什么类型的对象，而这违背了工厂方法模式的用意。
发生了这种退化之后就不再是工厂方法模式了。

3，工厂对象应当有一个抽象的超类型。换言之，应当有数个具体类作为一个抽象超类型的具体子类存在于工厂等级结构中。
如果等级结构中只有一个具体工厂类的话，那么抽象工厂角色也可以省略。
这时工厂方法模式就发生了退化，表现为针对工厂角色的多态性的丧失。
这种工厂方法模式仍然可以发挥一部分工厂方法模式的用意，可以由简单工厂模式来替代。


JDK里的应用：

java.lang.Proxy#newProxyInstance()
java.lang.Object#toString()
java.lang.Class#newInstance()
java.lang.reflect.Array#newInstance()
java.lang.reflect.Constructor#newInstance()
java.lang.Boolean#valueOf(String)
java.lang.Class#forName()
