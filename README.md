## 设计模式 ##

### 模式的一些概念 ###

模式化的过程是把问题抽象化，在忽略掉不重要的细节后，发现问题的一般性本质，并找到普遍适用的解决方案的过程。

人们在自己的环境中不断发现问题和寻找问题的解决方案的时候，发现有一些问题及其解决方案不断变换面孔重复出现，但是这些不同的面孔后面有着共同的性质，这些共同的本质就是模式。

模式的要素：

* 1.名字（Name）

	一个模式必须有一个有意义的、简短而准确的名字。一个好的名字可以使对模式的抽象变得容易。有时一个模式同时有多于一个的名字，这时候这些名字就应当作为别名列出。

* 2.问题（Problem）

	每一个模式必须有一个能够描述它的用意的问题，以便能够说明此模式在给定的环境和力中要达到的目标和结果。

* 3.环境或初始环境（Context或Initial Context）

	模式的问题和模式的解答出现所需要的前提条件。环境说明模式的适用范围，环境也是模式应用之前的起始位形。

* 4.力（Forces）

	力给出与模式有关的力和约束，它们怎样彼此相互作用，以及它们对实现目标所起的反作用，比如一个模式为所得到的好处付出的代价等。

* 5.解答（Solution）

	解答不仅要给出静态的结构，而且要给出动态的行为。其中静态的结构描述此模式的形式和组织，而动态的行为使得模式变成“活”的。模式的解答所描述的正好可以作为实现模式的指南。

* 6.举例（Examples）
	
	可以使用一个或多个示意性的应用来说明特定的真实环境，以及模式是怎样应用到环境上、改变环境并且给出当模式结束时的末态环境的。例子可以有助于读者理解模式的使用方法和适用性。

* 7.末态环境（Resulting Context）

	模式应用到环境之后的状态或位形。末态环境包括模式带来的好的和坏的结果，以及新状态中含有的其他问题和可能设计的其他有关系的模式。

* 8.推理（Rationale）

	推理解释本模式的步骤、规则，以及此模式作为一个整体是如何以特定的方式解决模式的力的，以及力和模式是如何协同合作的。它可以告诉设计师模式是怎样工作的，为什么可以工作，以及为什么此模式是好的。模式的解答可以描述模式外部的可见的结构和行为，而推理可以给出模式在系统表层下的深层结构和关键机制的洞察力。

* 9.其他相关模式（Related Patterns）

	这一要素应当描述在现有的系统中这个模式与其他模式的静态的和动态的关系。

* 10.已知的应用（Known Uses）

	在已有系统中模式出现和应用的例子，这有助于证明此模式是对一个重复发生的问题的可行的解答。

### 设计模式概念 ###

每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动。

模式依据其目的可分为创建型、结构型、行为型。创建型模式与对象的创建有关；结构型模式处理类或对象的组合；行为型模式对类或对象怎样交互和怎样分配职责进行描述。

模式依据其范围可以分为类模式和对象模式。类模式处理类和子类之间的关系，这些关系通过继承建立，是静态的，在编译时刻便确定下来了。对象模式处理对象间的关系，这些关系在运行时刻是可以变化的，是动态的。

对象的接口是指它所定义的所有的方法签名式（signature:包括方法名、返回类型和参数列），它描述了该对象所能接受的全部请求的集合，任何匹配对象接口中签名式的请求都可以发送给该对象。
抽象类的主要目的是为它的子类定义公共接口。

对象的类（class）和对象的类型（type）是有差别的：
一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现；但是对象的类型只与它的接口有关，接口即对象能相应的请求的集合。一个对象可以有多个类型，不同类的对象可以有相同的类型。类定义了对象所能执行的操作，也定义了对象的类型，一个对象是一个类的实例即指该对象支持类所定义的接口。

一个设计模式只有当它提供的灵活性是真正需要的时候，才有必要使用。复用的关键在于对新需求和已有需求发生变化时的预见性，要求你的系统设计能相应地改进。所以在必须考虑系统在它的生命周期内会发生怎样的变化。

可复用的面向对象设计的原则：

* 针对接口编程，而不是针对实现编程（不将变量声明为某个特定的具体类的实例对象，而是让它遵从抽象类所定义的接口）

* 优先使用对象组合，而不是类继承（最好只继承抽象基类），对象组合的设计具有更好的复用性。

#### MVC中的设计模式 ####

MVC 包括三类对象。模型 Model 是应用对象，视图 View 是它在屏幕上的表示，控制器 Controller 定义用户界面对用户输入的响应方式。

* Model 是代表组件状态和低级行为的部分，它管理着自己的状态并且处理所有对状态的操作，model 自己本身并不知道使用自己的 view 和 controller 是谁，系统维护着它和 view 之间的关系，当 model 发生了改变系统还负责通知相应的 view。

* View 代表了管理 model 所含有的数据的一个视觉上的呈现。一个 Model 可以有一个以上的 View,但是Swing中却很少有这样的情况。

* Controller 管理着 model 和用户之间的交互的控制。它提供了一些方法去处理当 model 的状态发生了变化时的情况。

视图必须保证它的显示正确的反映了模型的状态。一旦模型的数据发生变化，模型将通知有关视图，每个视图都相应地得到刷新自己的机会。

动态绑定：是指发送的请求直到运行时刻才受你的具体的实现的约束。因此，在知道任何有正确接口的对象都将接受此请求时，可以写一个一般的程序，它期待着那些具有该特定接口的对象。

在用对象建模时可以用两种方式连接对象：

* 关联：是一种弱连接，对象可以是小组或家庭的一部分，但它们不完全相互依赖。例如汽车和乘客。
* 聚合：表示把对象放在一起，变成一个更大的对象，形成一个"部分-整体"层次结构，它隐含了较大的依赖性，至少是整体对部分的依赖。例如房子和门窗。


**框架（Framework）**是构成一类特定软件可复用设计的一组相互协作的类，必须尽可能地灵活，可扩充。

* 框架规定了你的应用的体系结构，定义了整体结构，类和对象的分割，各部分的主要责任，类和对象怎么协作，以及控制流程。

* 框架预定义了这些设计参数，以便于应用设计者或实现者能集中精力于应用本身的特定细节。

* 框架记录了其应用领域的共同的设计决策，因而框架更强调设计复用，尽管框架常包括集体的以及可用的子类。

设计模式和框架的区别：

* 设计模式比框架更抽象
	
	框架能够用代码表示，而设计模式只有其特例才能表示为代码。框架能够使用程序设计语言写出来，不仅能被学习，也能被直接执行和复用。而设计模式在每一次被复用时，都需要被实现。

* 设计模式是比框架更小的体系结构元素：一个典型的框架包括了多个设计模式，而反之绝非如此

* 框架比设计模式更加特例化，框架总是针对一个特定的应用领域。

### 原则与模式 ###

设计模式是借助于 OO 手段（抽象、封装、继承、多态）和 OO 原则（封装变化、多用组合少用继承、针对接口编程不针对实现编程）来实现软件可复用、可扩展、可维护的目的。

* 开闭原则

	策略模式、简单工厂模式、工厂方法模式、抽象工厂模式、建造模式、桥梁模式、门面模式、调停者模式、访问者模式、迭代子模式

* 里氏替换原则

	策略模式、合成模式、代理模式

* 依赖倒置原则

	工厂方法模式、模版方法模式、迭代子模式

* 接口隔离原则
	
	备忘录模式、迭代子模式

* 最少知识法则

	门面模式、调停者模式


#### 解耦 ####

所谓**耦合**，就是两个实体的行为的某种强关联。而将它们的强关联去掉，就是耦合的解脱，或称解耦。在这里，解耦是指将抽象化和实现化之间的耦合解开，或者说是将它们之间的强关联改换成弱关联。

所谓**强关联**，就是在编译时期已经确定的，无法在运行时期动态改变的关联；所谓弱关联，就是可以动态的确定并且可以在运行时期动态地改变的关联。

在 Java 语言中，继承关系是强关联，而聚合关系是弱关联。将两个角色之间的继承关系改为聚合关系，就是将它们之间的强关联改换成弱关联。