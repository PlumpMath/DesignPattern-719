## 迭代子（Iterator）模式 ##

迭代子模式又叫游标（Cursor）模式，是对象的行为模式。迭代子模式可以顺序地访问一个聚集中的元素而不必暴露聚集的内部表象。

聚集：多个对象聚在一起形成的总体。聚集对象是能够包容一组对象的容器对象。聚集依赖于聚集结构的抽象化，具有复杂性和多样性。


### 为什么聚集需要迭代子？

聚集对象必须提供适当的方法，允许客户端能够按照一个线性顺序遍历所有的元素对象，把元素对象提取出来或者删除掉等。一个使用聚集的系统必然会使用这些方法操控聚集对象，因而在使用聚集的系统演化过程中，会出现两类问题：

* 迭代逻辑没有改变，但是需要将一种聚集换成另一种聚集。

	因为不同的聚集具有不同的遍历接口，所以需要修改客户端代码，以便将已有的迭代调用换成新聚集对象所要求的接口。

* 聚集不会改变，但是迭代方式需要改变。

	比如原来只需要读取元素和删除元素，但现在需要增加新的元素；或者原来的迭代仅仅遍历所有的元素，而现在则需要对元素加以过滤等。这时就只好修改聚集对象，修改已有的遍历方法，或者增加新的方法。

显然，出现这种情况是因为所涉及的聚集设计不符合开闭原则，也就是因为没有将不变的结构从系统中抽象出来，与可变成分分割，并将可变部分的各种实现封装起来。一个聪明的做法是应当使用更加抽象的处理方法，使得在进行迭代时，客户端根本无需知道所使用的聚集是哪种类型；
而当客户端需要使用全新的迭代逻辑时，只需引进一个新的迭代子对象即可，根本无需修改聚集对象本身。

迭代子模式便是这样的一个抽象化的概念。它把在元素之间游走的责任交给迭代器，而不是聚合对象。这不仅让聚合的接口和实现变得更简洁，也可以让聚合更专注在它所应该专注的事情上面（也就是管理对象集合），而不必去理会遍历的事情。


按照迭代的方向，迭代可以分为两种：正向迭代（Forward Iteration）和逆向迭代（Backward Iteration）。

迭代子模式涉及到以下几种角色：

抽象迭代子（Iterator）角色、具体迭代子（ConcreteIterator）角色、聚集（Aggregate）角色、具体聚集（ConcreteAggregate）角色。


### 迭代子模式的优点

* 迭代子模式简化了聚集的界面。迭代子具备了一个遍历接口，这样聚集的接口就不必具备遍历接口。

* 每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。因此，一个聚集对象可以同时有几个迭代在进行之中。

* 由于遍历算法被封装在迭代子角色里面，因此迭代的算法可以独立于聚集角色变化。由于客户端拿到的是一个迭代子对象，因此，不必知道聚集对象的类型，就可以读取和遍历聚集对象。这样即便聚集对象的类型发生变化，也不会影响到客户端的遍历过程。


JDK 里的应用：

	java.util.Iterator
	java.util.Enumeration
