## 状态（State）模式 ##

状态模式属于对象的行为模式。状态模式允许一个对象在其内部状态改变的时候改变其行为。这个对象看上去就像是改变了它的类一样。

状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于抽象状态类的一个子类。

状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。

模式所涉及到的角色有：

抽象状态（State）角色、具体状态（ConcreteState）角色、环境（Context）角色。


### 状态模式的效果

* 状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。

	当系统的状态变化时，系统便改变所选的子类。所有与一个特定的状态有关的行为都将被包装到一个特定的对象里面，使得行为的定义局域化。因为同样的原因，如果有新的状态以及它对应的行为需要定义时，可以很方便地通过设立新的子类的方式加到系统里，不需要改动其他的类。

* 由于每一个状态都被包装到了类里面，就可以不必采用过程性的处理方式，使用长篇累牍的条件转移语句。

* 使用状态模式使系统状态的变化变得很明显。

	由于不用一些属性（内部变量）来指明系统所处的状态，因此，就不同担心修改这些属性不当而造成的错误。

* 可以在系统的不同部分使用相同的一些状态类的对象。这种共享对象的办法是与享元模式相符合的。事实上，此时这些状态对象基本上是只有行为而没有内部状态的享元模式。

* 状态模式的缺点是会造成大量的小的状态类；优点是使程序免于大量的条件转移语句，使程序实际上更易于维护。

* 系统所选的状态子类均是从一个抽象状态类或接口继承而来，Java语言的特性使得在Java语言中使用状态模式较为安全。多态是状态模式的核心。


在以下的情况下可以使用状态模式：

* 一个对象的行为依赖于它所处的状态，对象的行为必须随着其状态的改变而改变。
* 对象在某个方法里依赖于一重或多重的条件转移语句，其中有大量的代码。状态模式把条件转移语句的每一个分支都包装到一个单独的类里。这使得这些条件转移分支能够以类的方式独立存在和演化。维护这些独立的类也就不再影响到系统的其他部分。


### 更多的讨论

* 谁来定义状态的变化。

	状态模式并没有规定哪一个角色决定状态发生转换的条件。如果转换条件是固定的，那么决定就应当由Context角色来做。然而如果让State子类自定决定它的下一个继任者是谁，以及在什么时候进行转换，就更有灵活性。

* 环境类可以把它自己作为参数传给状态对象。这样，一旦需要，状态对象就可以调用环境对象。


JDK里的应用：

	java.util.Iterator
	javax.faces.lifecycle.LifeCycle#execute()
